{{>partial_header}}

using {{packageName}}.Client.Model;
using {{packageName}}.Configuration;
using {{packageName}}.Exceptions;
using {{packageName}}.Telemetry;
using System.Diagnostics;

namespace {{packageName}}.ApiClient;

/// <summary>
///     API Client - used by all the API related methods to call the API. Handles token exchange and retries.
/// </summary>
public class ApiClient : IDisposable {
    private readonly BaseClient _baseClient;
    private readonly Configuration.Configuration _configuration;
    private readonly OAuth2Client? _oauth2Client;
    private readonly Metrics metrics = new();

    /// <summary>
    ///     Initializes a new instance of the <see cref="ApiClient" /> class.
    /// </summary>
    /// <param name="configuration">Client Configuration</param>
    /// <param name="userHttpClient">User Http Client - Allows Http Client reuse</param>
    public ApiClient(Configuration.Configuration configuration, HttpClient? userHttpClient = null) {
        configuration.IsValid();
        _configuration = configuration;
        _baseClient = new BaseClient(configuration, userHttpClient);

        if (_configuration.Credentials == null) {
            return;
        }

        switch (_configuration.Credentials.Method) {
            case CredentialsMethod.ApiToken:
                _configuration.DefaultHeaders["Authorization"] =
                    $"Bearer {_configuration.Credentials.Config!.ApiToken}";
                _baseClient = new BaseClient(_configuration, userHttpClient);
                break;
            case CredentialsMethod.ClientCredentials:
                _oauth2Client = new OAuth2Client(_configuration.Credentials, _baseClient,
                    new RetryParams { MaxRetry = _configuration.MaxRetry, MinWaitInMs = _configuration.MinWaitInMs });
                break;
            case CredentialsMethod.None:
            default:
                break;
        }
    }

    /// <summary>
    ///     Handles getting the access token, calling the API and potentially retrying
    ///     Based on:
    ///     https://github.com/auth0/auth0.net/blob/595ae80ccad8aa7764b80d26d2ef12f8b35bbeff/src/Auth0.ManagementApi/HttpClientManagementConnection.cs#L67
    /// </summary>
    /// <param name="requestBuilder"></param>
    /// <param name="apiName"></param>
    /// <param name="cancellationToken"></param>
    /// <typeparam name="T">Response Type</typeparam>
    /// <returns></returns>
    /// <exception cref="FgaApiAuthenticationError"></exception>
    public async Task<T> SendRequestAsync<T>(RequestBuilder requestBuilder, string apiName,
        CancellationToken cancellationToken = default) {
        IDictionary<string, string> additionalHeaders = new Dictionary<string, string>();

        var sw = Stopwatch.StartNew();
        if (_oauth2Client != null) {
            try {
                var token = await _oauth2Client.GetAccessTokenAsync();

                if (!string.IsNullOrEmpty(token)) {
                    additionalHeaders["Authorization"] = $"Bearer {token}";
                }
            }
            catch (ApiException e) {
                throw new FgaApiAuthenticationError("Invalid Client Credentials", apiName, e);
            }
        }

        var response = await Retry(async () =>
            await _baseClient.SendRequestAsync<T>(requestBuilder, additionalHeaders, apiName, cancellationToken));

        sw.Stop();
        metrics.buildForResponse(apiName, response.rawResponse, requestBuilder, _configuration.Credentials, sw,
            response.retryCount);

        return response.responseContent;
    }

    /// <summary>
    ///     Handles getting the access token, calling the API and potentially retrying (use for requests that return no
    ///     content)
    /// </summary>
    /// <param name="requestBuilder"></param>
    /// <param name="apiName"></param>
    /// <param name="cancellationToken"></param>
    /// <exception cref="FgaApiAuthenticationError"></exception>
    public async Task SendRequestAsync(RequestBuilder requestBuilder, string apiName,
        CancellationToken cancellationToken = default) {
        IDictionary<string, string> additionalHeaders = new Dictionary<string, string>();

        var sw = Stopwatch.StartNew();
        if (_oauth2Client != null) {
            try {
                var token = await _oauth2Client.GetAccessTokenAsync();

                if (!string.IsNullOrEmpty(token)) {
                    additionalHeaders["Authorization"] = $"Bearer {token}";
                }
            }
            catch (ApiException e) {
                throw new FgaApiAuthenticationError("Invalid Client Credentials", apiName, e);
            }
        }

        var response = await Retry(async () =>
            await _baseClient.SendRequestAsync<object>(requestBuilder, additionalHeaders, apiName, cancellationToken));

        sw.Stop();
        metrics.buildForResponse(apiName, response.rawResponse, requestBuilder, _configuration.Credentials, sw,
            response.retryCount);
    }

    private async Task<ResponseWrapper<TResult>> Retry<TResult>(Func<Task<ResponseWrapper<TResult>>> retryable) {
        var numRetries = 0;
        while (true) {
            try {
                numRetries++;

                var response = await retryable();

                response.retryCount = numRetries;

                return response;
            }
            catch (FgaApiRateLimitExceededError err) {
                if (numRetries > _configuration.MaxRetry) {
                    throw;
                }

                var waitInMs = (int)(err.ResetInMs == null || err.ResetInMs < _configuration.MinWaitInMs
                    ? _configuration.MinWaitInMs
                    : err.ResetInMs);

                await Task.Delay(waitInMs);
            }
            catch (FgaApiError err) {
                if (!err.ShouldRetry || numRetries > _configuration.MaxRetry) {
                    throw;
                }

                var waitInMs = _configuration.MinWaitInMs;

                await Task.Delay(waitInMs);
            }
        }
    }

    public void Dispose() => _baseClient.Dispose();
}
